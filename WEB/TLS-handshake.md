# TLS 핸드셰이크 (TLS Handshake)

TLS(Transport Layer Security) 핸드셰이크는 클라이언트와 서버가 안전한 통신 채널을 설정하기 위해 수행하는 초기 협상 절차이다. 이 과정에서 양측은 서로의 신원을 확인하고, 사용할 암호화 알고리즘과 세션 키를 합의하여 이후의 데이터 전송을 보호한다.

## 1. 핸드셰이크의 주요 목표

1. **프로토콜 및 암호화 스위트 협상**: 사용할 TLS 버전, 대칭키 암호, 해시 함수, 키 교환 알고리즘 등을 결정한다.
2. **서버(및 선택적으로 클라이언트) 인증**: 디지털 인증서를 통해 서버의 신원을 검증한다. 클라이언트 인증이 필요한 경우 클라이언트도 인증서를 제시한다.
3. **세션 키 생성 및 공유**: 키 교환 알고리즘을 이용해 암호화된 통신에 사용할 세션 키를 합의한다.
4. **메시지 무결성과 기밀성 보장 준비**: 합의된 키와 알고리즘으로 이후 데이터가 변조되거나 노출되지 않도록 한다.

## 2. 전형적인 TLS 1.2 핸드셰이크 흐름

1. **ClientHello**
   - 클라이언트가 서버에 TLS 버전, 지원하는 암호 스위트 목록, 랜덤 값(Client Random), 세션 재개를 위한 세션 ID 등을 전송한다.
2. **ServerHello**
   - 서버가 선택한 TLS 버전과 암호 스위트, 서버 랜덤(Server Random), 세션 ID 등을 클라이언트에 응답한다.
3. **Certificate**
   - 서버는 자신의 인증서를 보내어 신원을 증명한다. 루트 CA와 중간 CA의 체인을 포함할 수 있다.
4. **ServerKeyExchange** (필요한 경우)
   - RSA 이외의 키 교환 알고리즘(ECDHE 등)을 사용할 때 서버의 임시 공개키와 관련 파라미터를 전송한다.
5. **CertificateRequest** (선택 사항)
   - 서버가 클라이언트 인증서를 요구하는 경우 해당 메시지를 보낸다.
6. **ServerHelloDone**
   - 서버 측 초기 메시지가 완료되었음을 알린다.
7. **ClientKeyExchange**
   - 클라이언트가 프리마스터 시크릿(Pre-Master Secret)을 서버 공개키로 암호화하거나, ECDHE인 경우 클라이언트의 임시 공개키를 전송한다.
8. **Certificate** (선택 사항)
   - 서버가 클라이언트 인증을 요청했을 때 클라이언트가 자신의 인증서를 제공한다.
9. **CertificateVerify** (선택 사항)
   - 클라이언트는 개인키로 서명한 값을 전송하여 인증서 소유자임을 증명한다.
10. **ChangeCipherSpec**
    - 클라이언트는 이후 메시지부터 협상된 암호 스위트를 사용하겠다고 알린다.
11. **Finished**
    - 협상 과정 전체에 대한 해시 값을 전송하여 핸드셰이크 메시지의 무결성을 검증한다. 이후 서버도 ChangeCipherSpec과 Finished 메시지를 순서대로 전송한다.

## 3. TLS 1.3에서의 변화

TLS 1.3은 보안성과 성능을 개선하기 위해 핸드셰이크 절차가 간소화되었다.

- **메시지 수 감소**: 서버 인증서 및 키 교환 정보를 ServerHello 직후에 함께 보내 1-RTT(왕복 지연 한 번)만에 핸드셰이크가 완료된다.
- **Forward Secrecy 기본 적용**: 모든 키 교환이 (EC)DHE 기반으로 이루어져 세션 키가 노출되어도 과거 트래픽이 보호된다.
- **기존 불안전한 기능 제거**: RSA 키 교환, Static DH, RC4 등 취약한 옵션이 제외되었다.
- **0-RTT 데이터 전송 지원**: 이전 세션 정보를 재활용하여 클라이언트가 핸드셰이크 완료 전에 데이터를 전송할 수 있지만 재전송 공격에 주의해야 한다.

### TLS 1.3 기본 흐름 요약

1. 클라이언트가 ClientHello와 함께 키 공유(키 교환 파라미터)와 지원 암호 스위트를 전송한다.
2. 서버는 ServerHello에서 선택된 암호 스위트를 알리고, 자신의 키 공유 값을 전달한다.
3. 서버는 EncryptedExtensions, Certificate, CertificateVerify, Finished 메시지를 암호화된 형태로 보낸다.
4. 클라이언트는 서버 인증서를 검증한 뒤 Finished 메시지를 보내며, 세션 키가 활성화된다.

## 4. 핵심 개념 정리

- **Pre-Master Secret / Master Secret**: 키 교환을 통해 생성되는 비밀 값. 이를 기반으로 실제 대칭키(세션 키)가 파생된다.
- **Session Keys**: 데이터 암호화와 메시지 인증에 사용되는 대칭키. TLS 1.3에서는 다양한 traffic secret으로 파생된다.
- **Cipher Suite**: 키 교환, 인증, 암호화, 무결성 검증 알고리즘의 조합을 지정한다.
- **Forward Secrecy**: 세션 키가 노출되더라도 과거 통신 내용을 복호화할 수 없도록 하는 보안 속성.

## 5. 핸드셰이크 실패 원인과 대응

- **인증서 오류**: 만료, 신뢰되지 않은 CA, 도메인 불일치 등이 발생하면 클라이언트는 연결을 거부한다. 인증서 갱신, 체인 설정 등을 확인해야 한다.
- **프로토콜/암호 스위트 호환성 문제**: 양측이 지원하는 버전이나 스위트가 겹치지 않으면 실패한다. 서버 설정에서 최신 TLS 버전과 안전한 스위트를 활성화해야 한다.
- **네트워크 공격 탐지**: 핸드셰이크 메시지가 변조되면 Finished 검증에서 실패한다. 이는 중간자 공격을 차단하는 메커니즘이다.

## 6. 마무리

TLS 핸드셰이크는 안전한 웹 통신의 기반이며, 인증과 암호화, 무결성 보장을 동시에 달성하기 위한 복합적인 절차이다. 최신 표준을 적용하고 올바르게 구성함으로써 사용자는 안전하게 데이터를 주고받을 수 있다.
